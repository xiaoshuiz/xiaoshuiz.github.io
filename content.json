{"meta":{"title":"Dist Blog","subtitle":null,"description":null,"author":"xiaoshuiz","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"移动离线督察功能","date":"2018-09-24T07:16:24.000Z","path":"2018/09/24/offlineremote/","text":"目录 为什么做离线督察？ 怎么做离线督察？ 应用流程 为什么做离线督察？ 离线督察优点： 不接后台，摆脱网络问题a.是否将内网映射到外网 b.是否需要挂VPN 响应速度问题报脱了等待后台相应的问题，释放等待时间，一键响应。 安全问题摆脱信息传输安全问题，不用担心信息被抓走。 离线督察优点： 数据传输数据传输只能靠物理拷贝。增加了数据传输的不方便性。 数据管理需要后台操作与存储的问题现在则需要前端来处理，还需要数据管理的部分。 怎么做离线督察？1.设备验证与用户管理 在线的设备注册可以请求后台 公钥可以请求获取 登录可以通过公钥加密后请求来实现 那离线呢？ 这就引发了我们对于这个制作的思路,从下面就是整个设计思路。 一个证书对应一个设备，一个用户，唯有对应的一台设备以及对应的一个用户才能进行通过。 用户本地可以更改密码，但是密码找回只能重新联系管理员。具体流程如下： 2.数据管理因为离线版本无后台管理数据，设备本地的资源管理器则成为了应用数据展示的UI界面。那么这个界面的信息的可阅读性，也就制约着信息的选择与使用。这些文件数据： 在应用内进行读取。 在应用外直观展示。 如何提高这个界面的信息阅读性，对于文件资源管理器，无非就是数据分级结构与文件命名。文件夹的标识则成了重要的一部分，既要展示出自己不同的地方，又要减少程序加载的资源损耗。所以本地的资源目录格式便设计成了以下结构： 3.配置文件的存放与更新 获取 相比在线的可以实时获取图斑信息，离线只能读取本地的配置文件，且配置文件中只有图斑的名字，图斑的督察情况详情需要我们通过遍历文件来获取。由于数据复杂，在应用运行期间只会遍历获取一次。避免更新数据时卡顿。 刷新 由于图斑的督察会实时变更本地文件与文件夹信息，所以之前遍历的所有数据随时都在变更。但我们并不会再重新去遍历数据。则需要程序模拟出存储逻辑过程，准确更改本地信息，不会再去遍历本地数据。且避免无效路径。 4.图版上传 图版上传？一听这个名字就知道是在线功能，那么离线怎么实现呢？图斑锁定！除了和图版上传同样验证是否完成了多媒体和督察信息。 将上传图版变更为锁定图版 将批量上传变更为批量锁定 选择锁定图版之后无法在对多媒体文档以及督察信息进行编辑，只能进行查看。 待用户完全督察完成后，进行批量拷贝。 应用流程 结语&emsp;&emsp;从数据管理方面，Android作为前端设备，摒弃了后台独立开发的话，难免在数据管理与数据处理上感到吃力，放弃了信息传输的话，应用只能是个工具，不再是个平台。 &emsp;&emsp;从数据更新方面，实时的更新数据只能单方面的去模拟数据处理流程，对于应用外的干预，无法实时发现与做出相应。 &emsp;&emsp;从开发经验方面，通过这样的应用开发，让我了解并熟悉了移动督察的实质，操作逻辑与应用流程。对接下来的开发有着莫大的帮助。 &emsp;","raw":"---\ntitle: 移动离线督察功能\ndate: 2018-09-24 15:16:24\ntags: Android\ncategories: 张泉\n---\n<header> \n<td bgcolor=#0099ff>   \n<img src=\"https://i.imgur.com/7FykwPD.jpg\"  align=\"center\"/>\n   \n\n</td>\n\n</header>\n\n<br>\n\n* <font size=\"8\" face=\"黑体\" color=#51aa51 >**目录**</font>\n\n\n\n1. <font size=\"5\" face=\"黑体\" color=#000000 >**为什么做离线督察？**</font><br>\n\n\n2. <font size=\"5\" face=\"黑体\" color=#000000 >**怎么做离线督察？**</font><br>\n\n\n3. <font size=\"5\" face=\"黑体\" color=#000000 >**应用流程**</font><br>\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#ffb022 >**为什么**</font><font size=\"6\" face=\"黑体\" color=#005432 >**做离线督察？**</font>\n\n> 离线督察优点：\n\n\n\n1. 不接后台，摆脱网络问题<br>\na.是否将内网映射到外网   b.是否需要挂VPN\n<br>\n\n\n2. 响应速度问题<br>\n报脱了等待后台相应的问题，释放等待时间，一键响应。\n<br>\n\n\n3. 安全问题<br>\n摆脱信息传输安全问题，不用担心信息被抓走。\n<br>\n\n> 离线督察优点：\n\n\n1. 数据传输<br>\n数据传输只能靠物理拷贝。增加了数据传输的不方便性。\n<br>\n\n\n2. 数据管理<br>\n需要后台操作与存储的问题现在则需要前端来处理，还需要数据管理的部分。\n<br>\n\n\n\n\n\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#ffb022 >**怎么**</font><font size=\"6\" face=\"黑体\" color=#005432 >**做离线督察？**</font>\n\n\n###  1.<font size=\"5\" face=\"黑体\"  color=#ff4444>**设备验证与用户管理**</font><br>\n\n> 在线的设备注册可以请求后台\n\n> 公钥可以请求获取\n\n> 登录可以通过公钥加密后请求来实现\n\n <br>\n那离线呢？\t这就引发了我们对于这个制作的思路,从下面就是整个设计思路。\n\n<br>\n\n<img src=\"https://i.imgur.com/GrXqZsw.png\"  align=\"center\"/>\n\n<br>\n\n一个证书对应一个设备，一个用户，唯有对应的一台设备以及对应的一个用户才能进行通过。\n\n用户本地可以更改密码，但是密码找回只能重新联系管理员。具体流程如下：\n\n<br>\n\n<img src=\"https://i.imgur.com/UBA3iWH.jpg\"  align=\"center\"/>\n    \n<br>\n\n###   2.<font size=\"5\" face=\"黑体\">**数据管理**</font><br>\n<br>\n因为离线版本无后台管理数据，设备本地的资源管理器则成为了应用数据展示的UI界面。\n<br>\n<br>\n那么这个界面的信息的可阅读性，也就制约着信息的选择与使用。\n<br>\n<br>\n这些文件数据：\n\n>在应用内进行读取。\n\n\n>在应用外直观展示。\n\n\n如何提高这个界面的信息阅读性，对于文件资源管理器，无非就是数据分级结构与文件命名。\n<br>\n<br>\n文件夹的标识则成了重要的一部分，既要展示出自己不同的地方，又要减少程序加载的资源损耗。\n<br>\n<br>\n所以本地的资源目录格式便设计成了以下结构：\n<br>\n<br>\n\n<img src=\"https://i.imgur.com/fK2GUrD.jpg\"  align=\"center\"/>\n\n\n<br>\n\n\n\t\t\n\n###  3.<font size=\"5\" face=\"黑体\">**配置文件的存放与更新**</font><br>\n\n>   获取\n\n<br>\n相比在线的可以实时获取图斑信息，离线只能读取本地的配置文件，且配置文件中只有图斑的名字，图斑的督察情况详情需要我们通过遍历文件来获取。<br>\n由于数据复杂，在应用运行期间<font color=\"ff5555\">只会遍历获取一次</font>。避免更新数据时卡顿。\n\n\t \t\t\t\n\n\n<br>\n>   刷新\n\n<br>\n由于图斑的督察会<font color=\"ff5555\">实时变更本地文件与文件夹信息</font>，所以之前遍历的所有数据随时都在变更。但我们并不会再重新去遍历数据。<br>\n则需要程序<font color=\"ff5555\">模拟出存储逻辑过程</font>，准确更改本地信息，不会再去遍历本地数据。且避免无效路径。\n\n\n\n<br>\n\n\n              \n\n###  4.<font size=\"5\" face=\"黑体\">**图版上传**</font>\n<br>\n\n\n图版上传？一听这个名字就知道是在线功能，那么离线怎么实现呢？<br><br>\n图斑锁定！除了和图版上传同样验证是否完成了多媒体和督察信息。\n\n>将上传图版变更为锁定图版\n\n\n>将批量上传变更为批量锁定\n\n\n\n选择锁定图版之后无法在对多媒体文档\n以及督察信息进行编辑，只能进行查看。\n\n待用户完全督察完成后，进行批量拷贝。\n\n\n   \n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**应用流程**</font>\n\n<br>\n<img src=\"https://i.imgur.com/DIfAzrU.jpg\"  align=\"center\"/>\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;从数据管理方面，Android作为前端设备，摒弃了后台独立开发的话，难免在数据管理与数据处理上感到吃力，放弃了信息传输的话，应用只能是个工具，不再是个平台。\n<Br>\n&emsp;&emsp;从数据更新方面，实时的更新数据只能单方面的去模拟数据处理流程，对于应用外的干预，无法实时发现与做出相应。\n<Br>\n&emsp;&emsp;从开发经验方面，通过这样的应用开发，让我了解并熟悉了移动督察的实质，操作逻辑与应用流程。对接下来的开发有着莫大的帮助。\n\n\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n\n","content":"<header><br><td bgcolor=\"#0099ff\"><br><img src=\"https://i.imgur.com/7FykwPD.jpg\" align=\"center\"><br><br><br></td><br><br></header>\n\n<p><br></p>\n<ul>\n<li><font size=\"8\" face=\"黑体\" color=\"#51aa51\"><strong>目录</strong></font>\n\n\n\n</li>\n</ul>\n<ol>\n<li><font size=\"5\" face=\"黑体\" color=\"#000000\"><strong>为什么做离线督察？</strong></font><br></li>\n</ol>\n<ol start=\"2\">\n<li><font size=\"5\" face=\"黑体\" color=\"#000000\"><strong>怎么做离线督察？</strong></font><br></li>\n</ol>\n<ol start=\"3\">\n<li><font size=\"5\" face=\"黑体\" color=\"#000000\"><strong>应用流程</strong></font><br></li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"为什么做离线督察？\"><a href=\"#为什么做离线督察？\" class=\"headerlink\" title=\"为什么做离线督察？\"></a><font size=\"6\" face=\"黑体\" color=\"#ffb022\"><strong>为什么</strong></font><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>做离线督察？</strong></font></h2><blockquote>\n<p>离线督察优点：</p>\n</blockquote>\n<ol>\n<li>不接后台，摆脱网络问题<br><br>a.是否将内网映射到外网   b.是否需要挂VPN<br><br></li>\n</ol>\n<ol start=\"2\">\n<li>响应速度问题<br><br>报脱了等待后台相应的问题，释放等待时间，一键响应。<br><br></li>\n</ol>\n<ol start=\"3\">\n<li>安全问题<br><br>摆脱信息传输安全问题，不用担心信息被抓走。<br><br></li>\n</ol>\n<blockquote>\n<p>离线督察优点：</p>\n</blockquote>\n<ol>\n<li>数据传输<br><br>数据传输只能靠物理拷贝。增加了数据传输的不方便性。<br><br></li>\n</ol>\n<ol start=\"2\">\n<li>数据管理<br><br>需要后台操作与存储的问题现在则需要前端来处理，还需要数据管理的部分。<br><br></li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"怎么做离线督察？\"><a href=\"#怎么做离线督察？\" class=\"headerlink\" title=\"怎么做离线督察？\"></a><font size=\"6\" face=\"黑体\" color=\"#ffb022\"><strong>怎么</strong></font><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>做离线督察？</strong></font></h2><h3 id=\"1-设备验证与用户管理\"><a href=\"#1-设备验证与用户管理\" class=\"headerlink\" title=\"1.设备验证与用户管理\"></a>1.<font size=\"5\" face=\"黑体\" color=\"#ff4444\"><strong>设备验证与用户管理</strong></font><br></h3><blockquote>\n<p>在线的设备注册可以请求后台</p>\n</blockquote>\n<blockquote>\n<p>公钥可以请求获取</p>\n</blockquote>\n<blockquote>\n<p>登录可以通过公钥加密后请求来实现</p>\n</blockquote>\n<p> <br><br>那离线呢？    这就引发了我们对于这个制作的思路,从下面就是整个设计思路。</p>\n<p><br></p>\n<p><img src=\"https://i.imgur.com/GrXqZsw.png\" align=\"center\"></p>\n<p><br></p>\n<p>一个证书对应一个设备，一个用户，唯有对应的一台设备以及对应的一个用户才能进行通过。</p>\n<p>用户本地可以更改密码，但是密码找回只能重新联系管理员。具体流程如下：</p>\n<p><br></p>\n<p><img src=\"https://i.imgur.com/UBA3iWH.jpg\" align=\"center\"></p>\n<p><br></p>\n<h3 id=\"2-数据管理\"><a href=\"#2-数据管理\" class=\"headerlink\" title=\"2.数据管理\"></a>2.<font size=\"5\" face=\"黑体\"><strong>数据管理</strong></font><br></h3><p><br><br>因为离线版本无后台管理数据，设备本地的资源管理器则成为了应用数据展示的UI界面。<br><br><br><br><br>那么这个界面的信息的可阅读性，也就制约着信息的选择与使用。<br><br><br><br><br>这些文件数据：</p>\n<blockquote>\n<p>在应用内进行读取。</p>\n</blockquote>\n<blockquote>\n<p>在应用外直观展示。</p>\n</blockquote>\n<p>如何提高这个界面的信息阅读性，对于文件资源管理器，无非就是数据分级结构与文件命名。<br><br><br><br><br>文件夹的标识则成了重要的一部分，既要展示出自己不同的地方，又要减少程序加载的资源损耗。<br><br><br><br><br>所以本地的资源目录格式便设计成了以下结构：<br><br><br><br></p>\n<p><img src=\"https://i.imgur.com/fK2GUrD.jpg\" align=\"center\"></p>\n<p><br></p>\n<h3 id=\"3-配置文件的存放与更新\"><a href=\"#3-配置文件的存放与更新\" class=\"headerlink\" title=\"3.配置文件的存放与更新\"></a>3.<font size=\"5\" face=\"黑体\"><strong>配置文件的存放与更新</strong></font><br></h3><blockquote>\n<p>  获取</p>\n</blockquote>\n<p><br><br>相比在线的可以实时获取图斑信息，离线只能读取本地的配置文件，且配置文件中只有图斑的名字，图斑的督察情况详情需要我们通过遍历文件来获取。<br><br>由于数据复杂，在应用运行期间<font color=\"ff5555\">只会遍历获取一次</font>。避免更新数据时卡顿。</p>\n<p><br></p>\n<blockquote>\n<p>  刷新</p>\n</blockquote>\n<p><br><br>由于图斑的督察会<font color=\"ff5555\">实时变更本地文件与文件夹信息</font>，所以之前遍历的所有数据随时都在变更。但我们并不会再重新去遍历数据。<br><br>则需要程序<font color=\"ff5555\">模拟出存储逻辑过程</font>，准确更改本地信息，不会再去遍历本地数据。且避免无效路径。</p>\n<p><br></p>\n<h3 id=\"4-图版上传\"><a href=\"#4-图版上传\" class=\"headerlink\" title=\"4.图版上传\"></a>4.<font size=\"5\" face=\"黑体\"><strong>图版上传</strong></font></h3><p><br></p>\n<p>图版上传？一听这个名字就知道是在线功能，那么离线怎么实现呢？<br><br><br>图斑锁定！除了和图版上传同样验证是否完成了多媒体和督察信息。</p>\n<blockquote>\n<p>将上传图版变更为锁定图版</p>\n</blockquote>\n<blockquote>\n<p>将批量上传变更为批量锁定</p>\n</blockquote>\n<p>选择锁定图版之后无法在对多媒体文档<br>以及督察信息进行编辑，只能进行查看。</p>\n<p>待用户完全督察完成后，进行批量拷贝。</p>\n<h2 id=\"应用流程\"><a href=\"#应用流程\" class=\"headerlink\" title=\"应用流程\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>应用流程</strong></font></h2><p><br><br><img src=\"https://i.imgur.com/DIfAzrU.jpg\" align=\"center\"></p>\n<p><hr><br><br></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font></h2><p>&emsp;&emsp;从数据管理方面，Android作为前端设备，摒弃了后台独立开发的话，难免在数据管理与数据处理上感到吃力，放弃了信息传输的话，应用只能是个工具，不再是个平台。</p>\n<p><br><br>&emsp;&emsp;从数据更新方面，实时的更新数据只能单方面的去模拟数据处理流程，对于应用外的干预，无法实时发现与做出相应。</p>\n<p><br><br>&emsp;&emsp;从开发经验方面，通过这样的应用开发，让我了解并熟悉了移动督察的实质，操作逻辑与应用流程。对接下来的开发有着莫大的帮助。</p>\n<p><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>\n\n\n","slug":"offlineremote","updated":"2018-09-28T08:09:22.004Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/09/24/offlineremote/","excerpt":"","categories":[{"name":"张泉","slug":"张泉","permalink":"http://yoursite.com/categories/张泉/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"移动图例过滤功能","date":"2018-09-24T01:16:24.000Z","path":"2018/09/24/legendfilter/","text":"移动图例过滤功能 —– &emsp; xiaoshuiz&emsp; &emsp;&emsp;&emsp; 简介图例过滤是对于多图例图层的一种查看方式，这种查看方式方便对特定类型的图块进行统一查看。多图例图层一般为DynamicLayer与FeatureLayer,而且单个图例的图层与多个图例的图层，其渲染器也是不同的，单个图例的为SimpleRenderer，多个图例为UniqueValueRenderer。在本文中，图例过滤主要为对图例进行特定过滤达到多图层互斥过滤的效果，另外对于在线图例过滤使用了Layer Definition进行图层Visible控制问题。 实现逻辑略析 可视化与相关功能操作监听的基本实现 加载功能基础的分析操作图层与其图例 单个图例的点击并获取其LabelName 在线将ArcGisDynamicServiceLayer通过ArcGisFeatureLayer加载，并获取其Renderer转为UniqueValueRenderer（离线获取FeatureLayer的Renderer） 并获取Render中的Feild1字段（配置的过滤字段） WhereClause语句的拼接（过滤字段与LabelName中的值拼接成Sql Where语句） 在线通过设置ArcGisDynamicServiceLayer的LayerDefinition（离线通过设置FeatureLayer的DefinitionExpression）进行过滤 对于在线DynamicLayer多图层控制显示问题，将Visible控制可视改为Layer Definition控制可视，只维护一套属性。 重要部分代码实现1.LayerDefinition控制可视 /** ** 根据visibleIds 更新DynamicLayer 通过DynamicLayer的Definition进行控制显示 ** Definition中 1-&gt; “1=1” 表示图层 1 全部显示 **/ //要存储的LayerDefinitions Map&lt;String, Map&lt;Integer, String&gt;&gt; dynamicLayerDefinitionMap = TotalApplication.getDynamicLayerDefinitionMap(); //要操作的LayerDefinitions Map&lt;Integer, String&gt; layerDefinitions = dynamicLayer.getLayerDefinitions(); if (layerDefinitions==null) { layerDefinitions=new HashMap&lt;&gt;(); } if (isOpenLayer) { //显示 if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) { //从存储语句中获取之前的过滤语句 for (int visibleId : visibleIds) { Map&lt;Integer, String&gt; integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl()); if (integerStringMap.containsKey(visibleId) &amp;&amp;integerStringMap.get(visibleId)!=null &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(integerStringMap.get(visibleId))) { //已存该layer的id的Layer Definition Sql 语句 layerDefinitions.put(visibleId,integerStringMap.get(visibleId)); }else { //全部显示 layerDefinitions.put(visibleId,Constants.SQL_TURE); } } }else { //全部显示 for (int visibleId : visibleIds) { layerDefinitions.put(visibleId,Constants.SQL_TURE); } } }else { //关闭 if (!layerDefinitions.isEmpty()) { Map&lt;Integer, String&gt; integerStringMap; if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) { //存储中有这个Layer的Definition integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl()); }else { //存储中没有这个layer的definition integerStringMap=new HashMap&lt;&gt;(); } for (int visibleId : visibleIds) { if (layerDefinitions.containsKey(visibleId) &amp;&amp;layerDefinitions.get(visibleId)!=null &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(layerDefinitions.get(visibleId))) { //有可视语句，进行储存 integerStringMap.put(visibleId,layerDefinitions.get(visibleId)); } //取消可视 layerDefinitions.put(visibleId,Constants.SQL_FALSE); } TotalApplication.getDynamicLayerDefinitionMap().put(dynamicLayer.getUrl(),integerStringMap); }else { //一般走不到这，避免花里胡哨的操作 for (int visibleId : visibleIds) { //取消可视 layerDefinitions.put(visibleId,Constants.SQL_FALSE); } } } dynamicLayer.setLayerDefinitions(layerDefinitions); dynamicLayer.refresh(); 2.Render获取与过滤字段获取 离线获取 离线用的FeatureLayer.getRenderer() FeatureLayer featureLayer= (FeatureLayer) layer; //判断是否获取过，避免重复查询 if (TotalApplication.getInstanceFilterFieldMap().containsKey(layerName)) { filterField=TotalApplication.getInstanceFilterFieldMap().get(layerName); }else{ //记录已查询 以免无结果 重复查询 TotalApplication.getInstanceFilterFieldMap().put(layerName,Constants.NO_FILTER_FIELD); filterField=Constants.NO_FILTER_FIELD; //获取过滤字段 Renderer renderer = featureLayer.getRenderer(); if (renderer instanceof UniqueValueRenderer) { UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer; filterField = uniqueValueRenderer.getField1(); TotalApplication.getInstanceFilterFieldMap().put(layerName,filterField); } } 在线获取 在线通过加载ArcGisFeatureLayer获取Renderer中的过滤字段 //Renderer中过滤字段的查询和保存，避免重复加载 例：RDDM if (TotalApplication.getInstanceFilterFieldMap().keySet().contains(url+Constants.SPLIT_SYMBOL[4]+layerID)) { //通知过滤 }else{ final ArcGISFeatureLayer arcGISFeatureLayer= new ArcGISFeatureLayer(url+Constants.SPLIT_SYMBOL[4]+layerID, ArcGISFeatureLayer.MODE.SELECTION); final String finalUrl = url; final String finalLayerID = layerID; arcGISFeatureLayer.setOnStatusChangedListener(new OnStatusChangedListener() { @Override public void onStatusChanged(Object o, STATUS status) { if (status== STATUS.INITIALIZED) { //记录已查询 以免无结果 重复查询 TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),Constants.NO_FILTER_FIELD); Renderer renderer = arcGISFeatureLayer.getRenderer(); if (renderer!=null) { if (renderer instanceof UniqueValueRenderer) { UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer; //获取过滤字段 RDDM String filterField = uniqueValueRenderer.getField1(); if (filterField!=null&amp;&amp;!filterField.isEmpty()) { TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),filterField); } } } //通知过滤 } } }); } 3.图例过滤 离线过滤 离线用的FeatureLayer过滤 FeatureLayer的LayerDefinition为 String (Sql Where Clause)，无需控制图层，且可以和Visible混合使用 //图例过滤 例：YDDM = &apos;mc&apos; featureLayer.setDefinitionExpression(filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+finalLegendLabel+Constants.WHERE_QUOTATION_MARKS); 在线过滤 在线用的ArcGISDynamicMapServiceLayer过滤ArcGISDynamicMapServiceLayer的LayerDefinition为Map&lt; int(layerId) , String(Sql Where Clause) &gt;，得到所需数据进行过滤 //图例过滤 if (filterField!=null&amp;&amp;!Constants.NO_FILTER_FIELD.equalsIgnoreCase(filterField)&amp;&amp;!filterField.isEmpty()) { if (layer instanceof ArcGISDynamicMapServiceLayer) { //拼组Sql Where clause 并设置LayerDefinitions 进行过滤 Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions(); if (layerDefinitions==null) { layerDefinitions=new HashMap&lt;Integer, String&gt;(); } //map中： layerId -&gt; where clause YDDM = &apos;G1&apos; layerDefinitions.put(Integer.parseInt(layerId),filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+legendName+Constants.WHERE_QUOTATION_MARKS); ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions); ((ArcGISDynamicMapServiceLayer) layer).refresh(); } } 4.结束过滤(全部显示) 离线结束过滤 Map&lt;String, Layer&gt; layerMap = TotalApplication.getInstanceAllLayerMap(); if (layerMap.containsKey(name)) { Layer layer = layerMap.get(name); if (layer instanceof FeatureLayer) { //设置LayerDefinition ((FeatureLayer) layer).setDefinitionExpression(Constants.SQL_TURE); //数据改变 legendAdapter.selectLabel= Constants.NO_SELECT; TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT); legendAdapter.notifyDataSetChanged(); } } 在线结束过滤 //获取当前layer对应的Service Layer 的URL与Id List&lt;ThemeInfo&gt; theme = oneMapActivity.mDataSource.getTheme(); for (ThemeInfo themeInfo : theme) { if (name.equalsIgnoreCase(themeInfo.getName())) { serviceUID=themeInfo.getServiceUid(); layerID=themeInfo.getLayerId(); } } List&lt;MapServicesInfo&gt; mapServices = oneMapActivity.mDataSource.getMapServices(); for (MapServicesInfo mapService : mapServices) { if (serviceUID!=null&amp;&amp;serviceUID.equalsIgnoreCase(mapService.getName())) { url=mapService.getUrl(); } } //数据改变 legendAdapter.selectLabel= Constants.NO_SELECT; TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT); legendAdapter.notifyDataSetChanged(); //TODO 通知图例过滤 全部显示 if (layer instanceof ArcGISDynamicMapServiceLayer) { Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions(); if (layerDefinitions==null){ layerDefinitions=new HashMap&lt;Integer, String&gt;(); } layerDefinitions.put(Integer.parseInt(layerId),Constants.SQL_TURE); ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions); ((ArcGISDynamicMapServiceLayer) layer).refresh(); } 结语&emsp;&emsp;图例过滤功能的开发，既减少了用户手动查找相应地块和汇总的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作地图中同一类型的地块汇总，并通过绘制图层让用户在地图上更直观的看清板块对象。 &emsp;","raw":"---\ntitle: 移动图例过滤功能\ndate: 2018-09-24 09:16:24\ntags: Android\ncategories: 张泉\n---\n\n\n\n<header> \n<td bgcolor=#0099ff>   \n\n   <center><table><tr><td bgcolor=#333333><font size =7 face=\"黑体\" color=#ffffff>**移动图例过滤功能**</td></tr></table></center>\n   \n\n</td>\n\n</header>\n<div style=\"text-align: right\"><font size=\"4\" >\n----- &emsp;\n xiaoshuiz  \n&emsp;  &emsp;&emsp;&emsp;   \n </font>\n</div>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**简介**</font>\n\n\n\n<font size=\"4\">图例过滤是对于多图例图层的一种查看方式，这种查看方式方便对特定类型的图块进行统一查看。</font>\n<br>\n<font size=\"4\">多图例图层一般为DynamicLayer与FeatureLayer,而且单个图例的图层与多个图例的图层，其渲染器也是不同的，单个图例的为SimpleRenderer，多个图例为UniqueValueRenderer。</font>\n<br>\n<font color=#664499 size=\"4\">在本文中，图例过滤主要为对图例进行特定过滤达到多图层互斥过滤的效果，另外对于在线图例过滤使用了Layer Definition进行图层Visible控制问题。</font>\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**实现逻辑略析**</font>\n\n\n1. 可视化与相关功能操作监听的基本实现<br>\n\n\n2. 加载功能基础的分析操作图层与其图例<br>\n\n\n3. 单个图例的点击并获取其LabelName<br>\n\n\n4. <font color=#664499>在线将ArcGisDynamicServiceLayer通过ArcGisFeatureLayer加载，并获取其Renderer转为UniqueValueRenderer（离线获取FeatureLayer的Renderer） 并获取Render中的Feild1字段<font color=#ee0000>（配置的过滤字段）</font></font><br>\n\n\n5. <font color =#664499>WhereClause语句的拼接（过滤字段与LabelName中的值拼接成Sql Where语句）</font><br>\n\n\n6. <font color=#664499>在线通过设置ArcGisDynamicServiceLayer的LayerDefinition（离线通过设置FeatureLayer的DefinitionExpression）进行过滤</font><br>\n\n7. 对于在线DynamicLayer多图层控制显示问题，将Visible控制可视改为Layer Definition控制可视，只维护一套属性。\n\n\n\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#ffb022 >**重要**</font><font size=\"6\" face=\"黑体\" color=#005432 >**部分代码实现**</font>\n\n\n###  1.<font size=\"5\" face=\"黑体\">**LayerDefinition控制可视**</font><br>\n\n> /** \n> \n>   **   根据visibleIds 更新DynamicLayer 通过DynamicLayer的Definition进行控制显示\n>   \n>   ** Definition中 1-> \"1=1\" 表示图层 1 全部显示\n>   \n>   **/   \n <br>\n\n\n\n\n\t\t\n        //要存储的LayerDefinitions\n        Map<String, Map<Integer, String>> dynamicLayerDefinitionMap = TotalApplication.getDynamicLayerDefinitionMap();\n        //要操作的LayerDefinitions\n        Map<Integer, String> layerDefinitions = dynamicLayer.getLayerDefinitions();\n        if (layerDefinitions==null) {\n            layerDefinitions=new HashMap<>();\n        }\n        if (isOpenLayer) {\n            //显示\n            if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n                //从存储语句中获取之前的过滤语句\n                for (int visibleId : visibleIds) {\n\n                    Map<Integer, String> integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n                    if (integerStringMap.containsKey(visibleId)\n                            &&integerStringMap.get(visibleId)!=null\n                            &&!Constants.SQL_FALSE.equalsIgnoreCase(integerStringMap.get(visibleId))) {\n                        //已存该layer的id的Layer Definition Sql 语句\n                        layerDefinitions.put(visibleId,integerStringMap.get(visibleId));\n                    }else {\n                        //全部显示\n                        layerDefinitions.put(visibleId,Constants.SQL_TURE);\n                    }\n                }\n            }else {\n                //全部显示\n                for (int visibleId : visibleIds) {\n                    layerDefinitions.put(visibleId,Constants.SQL_TURE);\n                }\n            }\n        }else {\n            //关闭\n            if (!layerDefinitions.isEmpty()) {\n                Map<Integer, String> integerStringMap;\n                if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n                    //存储中有这个Layer的Definition\n                    integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n                }else {\n                    //存储中没有这个layer的definition\n                    integerStringMap=new HashMap<>();\n                }\n                for (int visibleId : visibleIds) {\n                    if (layerDefinitions.containsKey(visibleId)\n                            &&layerDefinitions.get(visibleId)!=null\n                            &&!Constants.SQL_FALSE.equalsIgnoreCase(layerDefinitions.get(visibleId))) {\n                        //有可视语句，进行储存\n                        integerStringMap.put(visibleId,layerDefinitions.get(visibleId));\n                    }\n                    //取消可视\n                    layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n                }\n                TotalApplication.getDynamicLayerDefinitionMap().put(dynamicLayer.getUrl(),integerStringMap);\n\n            }else {\n                //一般走不到这，避免花里胡哨的操作\n                for (int visibleId : visibleIds) {\n                    //取消可视\n                    layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n                }\n            }\n        }\n        dynamicLayer.setLayerDefinitions(layerDefinitions);\n        dynamicLayer.refresh();\n    \n<br>\n\n\n###  2.<font size=\"5\" face=\"黑体\">**Render获取与过滤字段获取**</font><br>\n\n>   离线获取\n\n离线用的FeatureLayer.getRenderer()\n<br>\n\n\t \t\t\tFeatureLayer featureLayer= (FeatureLayer) layer;\n                //判断是否获取过，避免重复查询\n                if (TotalApplication.getInstanceFilterFieldMap().containsKey(layerName)) {\n                    filterField=TotalApplication.getInstanceFilterFieldMap().get(layerName);\n                }else{\n                    //记录已查询 以免无结果 重复查询\n                    TotalApplication.getInstanceFilterFieldMap().put(layerName,Constants.NO_FILTER_FIELD);\n                    filterField=Constants.NO_FILTER_FIELD;\n                    //获取过滤字段\n                    Renderer renderer = featureLayer.getRenderer();\n                    if (renderer instanceof UniqueValueRenderer) {\n                        UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n                        filterField = uniqueValueRenderer.getField1();\n                        TotalApplication.getInstanceFilterFieldMap().put(layerName,filterField);\n                    }\n                }\n\n<br>\n\n>   在线获取\n\n在线通过加载ArcGisFeatureLayer获取Renderer中的过滤字段\n<br>\n\n\t\t\n        //Renderer中过滤字段的查询和保存，避免重复加载 例：RDDM\n        if (TotalApplication.getInstanceFilterFieldMap().keySet().contains(url+Constants.SPLIT_SYMBOL[4]+layerID)) {\n            //通知过滤\n        }else{\n            final ArcGISFeatureLayer arcGISFeatureLayer= new ArcGISFeatureLayer(url+Constants.SPLIT_SYMBOL[4]+layerID, ArcGISFeatureLayer.MODE.SELECTION);\n            final String finalUrl = url;\n            final String finalLayerID = layerID;\n            arcGISFeatureLayer.setOnStatusChangedListener(new OnStatusChangedListener() {\n                @Override\n                public void onStatusChanged(Object o, STATUS status) {\n                    if (status== STATUS.INITIALIZED) {\n                        //记录已查询 以免无结果 重复查询\n                        TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),Constants.NO_FILTER_FIELD);\n                        Renderer renderer = arcGISFeatureLayer.getRenderer();\n                        if (renderer!=null) {\n\n                            if (renderer instanceof UniqueValueRenderer) {\n                                UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n                                //获取过滤字段 RDDM\n                                String filterField = uniqueValueRenderer.getField1();\n                                if (filterField!=null&&!filterField.isEmpty()) {\n                                    TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),filterField);\n                                }\n                            }\n                        }\n\t\t\t\t\t\t//通知过滤\n                    }\n\n                }\n            });\n        }  \n\n\n###  3.<font size=\"5\" face=\"黑体\" color=#ff0000>**图例过滤**</font><br>\n\n>   离线过滤\n\n离线用的FeatureLayer过滤 FeatureLayer的LayerDefinition为 String (Sql Where Clause)，\n<br>\n无需控制图层，且可以和Visible混合使用\n\n\t \t\t\t\n                \n                //图例过滤 例：YDDM = 'mc'\n                featureLayer.setDefinitionExpression(filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+finalLegendLabel+Constants.WHERE_QUOTATION_MARKS);\n\n<br>\n>   在线过滤\n\n在线用的ArcGISDynamicMapServiceLayer过滤\n<br>ArcGISDynamicMapServiceLayer的LayerDefinition为Map< int(layerId) , String(Sql Where Clause) >，\n<br>\n得到所需数据进行过滤\n<br>\n\n\t\t\t\t\n                    //图例过滤\n                    if (filterField!=null&&!Constants.NO_FILTER_FIELD.equalsIgnoreCase(filterField)&&!filterField.isEmpty()) {\n                        if (layer instanceof ArcGISDynamicMapServiceLayer) {\n                            //拼组Sql Where clause 并设置LayerDefinitions 进行过滤\n                            Map<Integer, String> layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n                            if (layerDefinitions==null) {\n                                layerDefinitions=new HashMap<Integer, String>();\n                            }\n                            //map中： layerId -> where clause   YDDM = 'G1'\n                            layerDefinitions.put(Integer.parseInt(layerId),filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+legendName+Constants.WHERE_QUOTATION_MARKS);\n                            ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n                            ((ArcGISDynamicMapServiceLayer) layer).refresh();\n                        }\n                    }\n              \n\n\n\n###  4.<font size=\"5\" face=\"黑体\" color=#ff0000>**结束过滤(全部显示)**</font><br>\n\n>  离线结束过滤\n\n\n\n\t\tMap<String, Layer> layerMap = TotalApplication.getInstanceAllLayerMap();\n        if (layerMap.containsKey(name)) {\n            Layer layer = layerMap.get(name);\n            if (layer instanceof FeatureLayer) {\n                //设置LayerDefinition\n                ((FeatureLayer) layer).setDefinitionExpression(Constants.SQL_TURE);\n                //数据改变\n                legendAdapter.selectLabel= Constants.NO_SELECT;\n                TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\n                legendAdapter.notifyDataSetChanged();\n            }\n        }\n\n<br>\n\n>  在线结束过滤\n\n\n\n\t\t//获取当前layer对应的Service Layer 的URL与Id\n        List<ThemeInfo> theme = oneMapActivity.mDataSource.getTheme();\n        for (ThemeInfo themeInfo : theme) {\n            if (name.equalsIgnoreCase(themeInfo.getName())) {\n                serviceUID=themeInfo.getServiceUid();\n                layerID=themeInfo.getLayerId();\n            }\n        }\n        List<MapServicesInfo> mapServices = oneMapActivity.mDataSource.getMapServices();\n        for (MapServicesInfo mapService : mapServices) {\n            if (serviceUID!=null&&serviceUID.equalsIgnoreCase(mapService.getName())) {\n                url=mapService.getUrl();\n            }\n        }\n        //数据改变\n        legendAdapter.selectLabel= Constants.NO_SELECT;\n        TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\n        legendAdapter.notifyDataSetChanged();\n\t\t//TODO 通知图例过滤\n\n<br>\n全部显示\n\n    if (layer instanceof ArcGISDynamicMapServiceLayer) {\n    \tMap<Integer, String> layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n        if (layerDefinitions==null){\n        \tlayerDefinitions=new HashMap<Integer, String>();\n    \t}\n    \tlayerDefinitions.put(Integer.parseInt(layerId),Constants.SQL_TURE);\n    \t((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n    \t((ArcGISDynamicMapServiceLayer) layer).refresh();\n\t}\n                \n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;图例过滤功能的开发，既减少了用户手动查找相应地块和汇总的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作地图中同一类型的地块汇总，并通过绘制图层让用户在地图上更直观的看清板块对象。\n\n\n\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n\n\n\n\n\n\n\n","content":"<p><header> </header></p>\n<td bgcolor=\"#0099ff\"><br><br>   <center><table><tr><td bgcolor=\"#333333\"><font size=\"7\" face=\"黑体\" color=\"#ffffff\"><strong>移动图例过滤功能</strong></font></td></tr></table></center><br><br><br></td>\n\n<p></p>\n<p><div style=\"text-align: right\"><font size=\"4\"><br>—– &emsp;<br> xiaoshuiz<br>&emsp;  &emsp;&emsp;&emsp;<br> </font><br></div><br><br></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>简介</strong></font></h2><font size=\"4\">图例过滤是对于多图例图层的一种查看方式，这种查看方式方便对特定类型的图块进行统一查看。</font><br><br><br><font size=\"4\">多图例图层一般为DynamicLayer与FeatureLayer,而且单个图例的图层与多个图例的图层，其渲染器也是不同的，单个图例的为SimpleRenderer，多个图例为UniqueValueRenderer。</font><br><br><br><font color=\"#664499\" size=\"4\">在本文中，图例过滤主要为对图例进行特定过滤达到多图层互斥过滤的效果，另外对于在线图例过滤使用了Layer Definition进行图层Visible控制问题。</font>\n\n<p><hr><br><br></p>\n<h2 id=\"实现逻辑略析\"><a href=\"#实现逻辑略析\" class=\"headerlink\" title=\"实现逻辑略析\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>实现逻辑略析</strong></font></h2><ol>\n<li>可视化与相关功能操作监听的基本实现<br></li>\n</ol>\n<ol start=\"2\">\n<li>加载功能基础的分析操作图层与其图例<br></li>\n</ol>\n<ol start=\"3\">\n<li>单个图例的点击并获取其LabelName<br></li>\n</ol>\n<ol start=\"4\">\n<li><font color=\"#664499\">在线将ArcGisDynamicServiceLayer通过ArcGisFeatureLayer加载，并获取其Renderer转为UniqueValueRenderer（离线获取FeatureLayer的Renderer） 并获取Render中的Feild1字段<font color=\"#ee0000\">（配置的过滤字段）</font></font><br></li>\n</ol>\n<ol start=\"5\">\n<li><font color=\"#664499\">WhereClause语句的拼接（过滤字段与LabelName中的值拼接成Sql Where语句）</font><br></li>\n</ol>\n<ol start=\"6\">\n<li><p><font color=\"#664499\">在线通过设置ArcGisDynamicServiceLayer的LayerDefinition（离线通过设置FeatureLayer的DefinitionExpression）进行过滤</font><br></p>\n</li>\n<li><p>对于在线DynamicLayer多图层控制显示问题，将Visible控制可视改为Layer Definition控制可视，只维护一套属性。</p>\n</li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"重要部分代码实现\"><a href=\"#重要部分代码实现\" class=\"headerlink\" title=\"重要部分代码实现\"></a><font size=\"6\" face=\"黑体\" color=\"#ffb022\"><strong>重要</strong></font><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>部分代码实现</strong></font></h2><h3 id=\"1-LayerDefinition控制可视\"><a href=\"#1-LayerDefinition控制可视\" class=\"headerlink\" title=\"1.LayerDefinition控制可视\"></a>1.<font size=\"5\" face=\"黑体\"><strong>LayerDefinition控制可视</strong></font><br></h3><blockquote>\n<p>/** </p>\n<p>  **   根据visibleIds 更新DynamicLayer 通过DynamicLayer的Definition进行控制显示</p>\n<p>  ** Definition中 1-&gt; “1=1” 表示图层 1 全部显示</p>\n<p>  **/<br> <br></p>\n</blockquote>\n<pre><code>//要存储的LayerDefinitions\nMap&lt;String, Map&lt;Integer, String&gt;&gt; dynamicLayerDefinitionMap = TotalApplication.getDynamicLayerDefinitionMap();\n//要操作的LayerDefinitions\nMap&lt;Integer, String&gt; layerDefinitions = dynamicLayer.getLayerDefinitions();\nif (layerDefinitions==null) {\n    layerDefinitions=new HashMap&lt;&gt;();\n}\nif (isOpenLayer) {\n    //显示\n    if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n        //从存储语句中获取之前的过滤语句\n        for (int visibleId : visibleIds) {\n\n            Map&lt;Integer, String&gt; integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n            if (integerStringMap.containsKey(visibleId)\n                    &amp;&amp;integerStringMap.get(visibleId)!=null\n                    &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(integerStringMap.get(visibleId))) {\n                //已存该layer的id的Layer Definition Sql 语句\n                layerDefinitions.put(visibleId,integerStringMap.get(visibleId));\n            }else {\n                //全部显示\n                layerDefinitions.put(visibleId,Constants.SQL_TURE);\n            }\n        }\n    }else {\n        //全部显示\n        for (int visibleId : visibleIds) {\n            layerDefinitions.put(visibleId,Constants.SQL_TURE);\n        }\n    }\n}else {\n    //关闭\n    if (!layerDefinitions.isEmpty()) {\n        Map&lt;Integer, String&gt; integerStringMap;\n        if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n            //存储中有这个Layer的Definition\n            integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n        }else {\n            //存储中没有这个layer的definition\n            integerStringMap=new HashMap&lt;&gt;();\n        }\n        for (int visibleId : visibleIds) {\n            if (layerDefinitions.containsKey(visibleId)\n                    &amp;&amp;layerDefinitions.get(visibleId)!=null\n                    &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(layerDefinitions.get(visibleId))) {\n                //有可视语句，进行储存\n                integerStringMap.put(visibleId,layerDefinitions.get(visibleId));\n            }\n            //取消可视\n            layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n        }\n        TotalApplication.getDynamicLayerDefinitionMap().put(dynamicLayer.getUrl(),integerStringMap);\n\n    }else {\n        //一般走不到这，避免花里胡哨的操作\n        for (int visibleId : visibleIds) {\n            //取消可视\n            layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n        }\n    }\n}\ndynamicLayer.setLayerDefinitions(layerDefinitions);\ndynamicLayer.refresh();\n</code></pre><p><br></p>\n<h3 id=\"2-Render获取与过滤字段获取\"><a href=\"#2-Render获取与过滤字段获取\" class=\"headerlink\" title=\"2.Render获取与过滤字段获取\"></a>2.<font size=\"5\" face=\"黑体\"><strong>Render获取与过滤字段获取</strong></font><br></h3><blockquote>\n<p>  离线获取</p>\n</blockquote>\n<p>离线用的FeatureLayer.getRenderer()<br><br></p>\n<pre><code> FeatureLayer featureLayer= (FeatureLayer) layer;\n//判断是否获取过，避免重复查询\nif (TotalApplication.getInstanceFilterFieldMap().containsKey(layerName)) {\n    filterField=TotalApplication.getInstanceFilterFieldMap().get(layerName);\n}else{\n    //记录已查询 以免无结果 重复查询\n    TotalApplication.getInstanceFilterFieldMap().put(layerName,Constants.NO_FILTER_FIELD);\n    filterField=Constants.NO_FILTER_FIELD;\n    //获取过滤字段\n    Renderer renderer = featureLayer.getRenderer();\n    if (renderer instanceof UniqueValueRenderer) {\n        UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n        filterField = uniqueValueRenderer.getField1();\n        TotalApplication.getInstanceFilterFieldMap().put(layerName,filterField);\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线获取</p>\n</blockquote>\n<p>在线通过加载ArcGisFeatureLayer获取Renderer中的过滤字段<br><br></p>\n<pre><code>//Renderer中过滤字段的查询和保存，避免重复加载 例：RDDM\nif (TotalApplication.getInstanceFilterFieldMap().keySet().contains(url+Constants.SPLIT_SYMBOL[4]+layerID)) {\n    //通知过滤\n}else{\n    final ArcGISFeatureLayer arcGISFeatureLayer= new ArcGISFeatureLayer(url+Constants.SPLIT_SYMBOL[4]+layerID, ArcGISFeatureLayer.MODE.SELECTION);\n    final String finalUrl = url;\n    final String finalLayerID = layerID;\n    arcGISFeatureLayer.setOnStatusChangedListener(new OnStatusChangedListener() {\n        @Override\n        public void onStatusChanged(Object o, STATUS status) {\n            if (status== STATUS.INITIALIZED) {\n                //记录已查询 以免无结果 重复查询\n                TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),Constants.NO_FILTER_FIELD);\n                Renderer renderer = arcGISFeatureLayer.getRenderer();\n                if (renderer!=null) {\n\n                    if (renderer instanceof UniqueValueRenderer) {\n                        UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n                        //获取过滤字段 RDDM\n                        String filterField = uniqueValueRenderer.getField1();\n                        if (filterField!=null&amp;&amp;!filterField.isEmpty()) {\n                            TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),filterField);\n                        }\n                    }\n                }\n                //通知过滤\n            }\n\n        }\n    });\n}  \n</code></pre><h3 id=\"3-图例过滤\"><a href=\"#3-图例过滤\" class=\"headerlink\" title=\"3.图例过滤\"></a>3.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>图例过滤</strong></font><br></h3><blockquote>\n<p>  离线过滤</p>\n</blockquote>\n<p>离线用的FeatureLayer过滤 FeatureLayer的LayerDefinition为 String (Sql Where Clause)，<br><br><br>无需控制图层，且可以和Visible混合使用</p>\n<pre><code>//图例过滤 例：YDDM = &apos;mc&apos;\nfeatureLayer.setDefinitionExpression(filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+finalLegendLabel+Constants.WHERE_QUOTATION_MARKS);\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线过滤</p>\n</blockquote>\n<p>在线用的ArcGISDynamicMapServiceLayer过滤<br><br>ArcGISDynamicMapServiceLayer的LayerDefinition为Map&lt; int(layerId) , String(Sql Where Clause) &gt;，<br><br><br>得到所需数据进行过滤<br><br></p>\n<pre><code>//图例过滤\nif (filterField!=null&amp;&amp;!Constants.NO_FILTER_FIELD.equalsIgnoreCase(filterField)&amp;&amp;!filterField.isEmpty()) {\n    if (layer instanceof ArcGISDynamicMapServiceLayer) {\n        //拼组Sql Where clause 并设置LayerDefinitions 进行过滤\n        Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n        if (layerDefinitions==null) {\n            layerDefinitions=new HashMap&lt;Integer, String&gt;();\n        }\n        //map中： layerId -&gt; where clause   YDDM = &apos;G1&apos;\n        layerDefinitions.put(Integer.parseInt(layerId),filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+legendName+Constants.WHERE_QUOTATION_MARKS);\n        ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n        ((ArcGISDynamicMapServiceLayer) layer).refresh();\n    }\n}\n</code></pre><h3 id=\"4-结束过滤-全部显示\"><a href=\"#4-结束过滤-全部显示\" class=\"headerlink\" title=\"4.结束过滤(全部显示)\"></a>4.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>结束过滤(全部显示)</strong></font><br></h3><blockquote>\n<p> 离线结束过滤</p>\n</blockquote>\n<pre><code>Map&lt;String, Layer&gt; layerMap = TotalApplication.getInstanceAllLayerMap();\nif (layerMap.containsKey(name)) {\n    Layer layer = layerMap.get(name);\n    if (layer instanceof FeatureLayer) {\n        //设置LayerDefinition\n        ((FeatureLayer) layer).setDefinitionExpression(Constants.SQL_TURE);\n        //数据改变\n        legendAdapter.selectLabel= Constants.NO_SELECT;\n        TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\n        legendAdapter.notifyDataSetChanged();\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p> 在线结束过滤</p>\n</blockquote>\n<pre><code>//获取当前layer对应的Service Layer 的URL与Id\nList&lt;ThemeInfo&gt; theme = oneMapActivity.mDataSource.getTheme();\nfor (ThemeInfo themeInfo : theme) {\n    if (name.equalsIgnoreCase(themeInfo.getName())) {\n        serviceUID=themeInfo.getServiceUid();\n        layerID=themeInfo.getLayerId();\n    }\n}\nList&lt;MapServicesInfo&gt; mapServices = oneMapActivity.mDataSource.getMapServices();\nfor (MapServicesInfo mapService : mapServices) {\n    if (serviceUID!=null&amp;&amp;serviceUID.equalsIgnoreCase(mapService.getName())) {\n        url=mapService.getUrl();\n    }\n}\n//数据改变\nlegendAdapter.selectLabel= Constants.NO_SELECT;\nTotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\nlegendAdapter.notifyDataSetChanged();\n//TODO 通知图例过滤\n</code></pre><p><br><br>全部显示</p>\n<pre><code>if (layer instanceof ArcGISDynamicMapServiceLayer) {\n    Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n    if (layerDefinitions==null){\n        layerDefinitions=new HashMap&lt;Integer, String&gt;();\n    }\n    layerDefinitions.put(Integer.parseInt(layerId),Constants.SQL_TURE);\n    ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n    ((ArcGISDynamicMapServiceLayer) layer).refresh();\n}\n</code></pre><p><hr><br><br></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font></h2><p>&emsp;&emsp;图例过滤功能的开发，既减少了用户手动查找相应地块和汇总的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作地图中同一类型的地块汇总，并通过绘制图层让用户在地图上更直观的看清板块对象。</p>\n<p><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>\n\n\n\n\n\n\n\n\n","slug":"legendfilter","updated":"2018-09-28T08:09:07.302Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/09/24/legendfilter/","excerpt":"","categories":[{"name":"张泉","slug":"张泉","permalink":"http://yoursite.com/categories/张泉/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"移动用地分析","date":"2018-08-13T01:36:24.000Z","path":"2018/08/13/landanalysis/","text":"移动用地分析功能 简介用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。 实现逻辑略析 可视化与相关功能操作窗口的基本实现 加载功能基础的地图底图与分析操作图层 分析区域的选择并获取当前图形 离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤 获得结果FeatureResult，从中获取Geometry（并非与绘制图形做过交叉处理的Geometry）与Attribute 图形切割与面积计算 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定 重要部分代码实现1.分析区域选择//通过多点集合绘制几何图形 polygon.lineTo(currentPoint); currentGraphic = new Graphic(polygon, symbol); drawLayer.updateGraphic(currentGraphicIndex,currentGraphic); pointGraphic=new Graphic(multiPoint,pointSymbol); drawLayer.updateGraphic(pointGraphicIndex,pointGraphic); multiPoint.add(currentPoint); if(lastGraphicIndex!=-1){ drawLayer.removeGraphic(lastGraphicIndex); } lastGraphic=new Graphic(currentPoint,lastSymbol); lastGraphicIndex=drawLayer.addGraphic(lastGraphic); 2.地图查询 离线查询 离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); //设置区域 if (isALL) { queryParams.setGeometry(mapView_main.getExtent()); }else { Polygon queryPolygon=measureManager.getpolygon(); queryParams.setGeometry(queryPolygon); } //设置过滤字段 queryParams.setOutFields(new String[]{&quot;*&quot;}); landAnalysisResultInfos=new ArrayList&lt;&gt;(); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; FeatureLayer featureLayer=(FeatureLayer)layer; resultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener); try { //获取结果 featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { Iterator it = featureResult.iterator(); while (it.hasNext()){ GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next(); Geometry geometry=geodatabaseFeature.getGeometry(); &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } 在线查询 在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); Polygon Querypolygon=measureManager.getpolygon(); queryParams.setGeometry(Querypolygon); landAnalysisResultInfos=new ArrayList&lt;&gt;(); queryParams.setOutFields(new String[]{&quot;*&quot;}); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; ArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer; QueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0)); resultFuture=queryTask.execute(queryParams, callbackListener); try { featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { for (Object element : featureResult) { if (element instanceof Feature) { Feature f = (Feature) element; Geometry geometry=f.getGeometry(); Map&lt;String, Object&gt; featureMap=f.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } } } 3.图形交叉处理 通过调用GeometeyEngine.intersect()方法获取。 Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference()); 4.面积计算 由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。 /** *通过在地图上的Area大小计算百分比与实际面积 * * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo} * @return 一个结果的数组 变更了参数数组中成员的属性 */ public static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){ /*计算实际面积 */ double MUM=0; for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { if (landResourceInfo.getYDMJ()==null) { landResourceInfos.remove(landResourceInfo); continue; } Double visualArea=landResourceInfo.getGeometry().calculateArea2D(); Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D(); Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea; landResourceInfo.setYDMJ(realArea); //累计求和 MUM=MUM+landResourceInfo.getYDMJ(); } /*分别计算百分比*/ for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100)); } return landResourceInfos; } 5.图形展示 由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。 /** * 结果列表点击效果 */ private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { resultDrawerLayer.removeAll(); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE))); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK))); Envelope tempEnvelope = new Envelope(); landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope); Point tempPoint = tEnvelope.getCenter(); mapView_main.centerAt(tempPoint,true); } }; 结语&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。 相关关键代码查看 &emsp;","raw":"---\ntitle: 移动用地分析\ndate: 2018-08-13 09:36:24\ntags: Android\ncategories: 张泉\n---\n<header> \n<td bgcolor=#0099ff>   \n\n   <center><table><tr><td bgcolor=#333333><font size =7 face=\"黑体\" color=#ffffff>**移动用地分析功能**</td></tr></table></center>\n   \n\n</td>\n</header>\n\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**简介**</font>\n\n\n\n<font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font>\n<br>\n<font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font>\n<br>\n<font color=#664499 size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font>\n\n\n<hr>\n\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**实现逻辑略析**</font>\n\n\n1. 可视化与相关功能操作窗口的基本实现<br>\n\n\n2. 加载功能基础的地图底图与分析操作图层<br>\n\n\n3. 分析区域的选择并获取当前图形<br>\n\n\n4. <font color=#664499>离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br>\n\n\n5. <font color=#664499>获得结果FeatureResult，从中获取Geometry<font color=#ee0000>（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br>\n\n\n6. <font color =#664499>图形切割与面积计算</font><br>\n\n\n7. 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br>\n\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**重要部分代码实现**</font>\n\n\n\n### 1.<font size=\"5\" face=\"黑体\">**分析区域选择**</font><br>\n\n\n\t//通过多点集合绘制几何图形\n\tpolygon.lineTo(currentPoint);\n\tcurrentGraphic = new Graphic(polygon, symbol);\n\tdrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\tpointGraphic=new Graphic(multiPoint,pointSymbol);\n\tdrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n\tmultiPoint.add(currentPoint);\n\tif(lastGraphicIndex!=-1){\n\t\tdrawLayer.removeGraphic(lastGraphicIndex);\n\t}\n\tlastGraphic=new Graphic(currentPoint,lastSymbol);\n\tlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n    \n<br>\n\n\n### 2.<font size=\"5\" face=\"黑体\" color=#ff0000>**地图查询**</font><br>\n\n>   离线查询\n\n离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\t//设置区域\n\tif (isALL) {\n\tqueryParams.setGeometry(mapView_main.getExtent());\n\t}else {\n\t\tPolygon queryPolygon=measureManager.getpolygon();\n\t\tqueryParams.setGeometry(queryPolygon);\n\t}\n\t//设置过滤字段\n\tqueryParams.setOutFields(new String[]{\"*\"});\n\tlandAnalysisResultInfos=new ArrayList<>();\n\tList<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();                    \n\tFuture<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tFeatureLayer featureLayer=(FeatureLayer)layer;\n\tresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\n\ttry {\n\t\t//获取结果\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tIterator it = featureResult.iterator();\n\t\t while (it.hasNext()){\n\t\tGeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n\t\tGeometry geometry=geodatabaseFeature.getGeometry();\n\t\t<String, Object> featureMap=geodatabaseFeature.getAttributes();\n\n\t\tif(geometry!=null){\n\t\t\t//进行图形处理\n\t\t}\n\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t//进行内容详情提取处理\n\t\t}\n\t}\n<br>\n>   在线查询\n\n在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\tPolygon Querypolygon=measureManager.getpolygon();\n\tqueryParams.setGeometry(Querypolygon);\n    landAnalysisResultInfos=new ArrayList<>();\n    queryParams.setOutFields(new String[]{\"*\"});\n    List<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();\n    Future<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\n\tQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\n\tresultFuture=queryTask.execute(queryParams, callbackListener);\n\ttry {\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tfor (Object element : featureResult) {\n\t\t\tif (element instanceof Feature) {\n\t\t\t\tFeature f = (Feature) element;\n\t\t\t\tGeometry geometry=f.getGeometry();\n\t\t\t\tMap<String, Object> featureMap=f.getAttributes();\n\t\t\t\tif(geometry!=null){\n\t\t\t\t\t//进行图形处理\n\t\t\t\t}\n\t\t\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t\t\t//进行内容详情提取处理\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}        \n<br>\n\n\n### 3.<font size=\"5\" face=\"黑体\" color=#ff0000>**图形交叉处理**</font><br>\n\n>  通过调用GeometeyEngine.intersect()方法获取。\n\n\tGeometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n\n<br>\n\n\n### 4.<font size=\"5\" face=\"黑体\">**面积计算**</font><br>\n\n>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br>\n>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。\n\n\t/**\n     *通过在地图上的Area大小计算百分比与实际面积\n     *\n     * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n     * @return 一个结果的数组 变更了参数数组中成员的属性\n     */\n    public static List<LandAnalysisResultInfo> getLandPercentValue(List<LandAnalysisResultInfo> landResourceInfos){\n        /*计算实际面积 */\n        double MUM=0;\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            if (landResourceInfo.getYDMJ()==null) {\n                landResourceInfos.remove(landResourceInfo);\n                continue;\n            }\n            Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n            Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n            Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n            landResourceInfo.setYDMJ(realArea);\n\n            //累计求和\n            MUM=MUM+landResourceInfo.getYDMJ();\n        }\n        /*分别计算百分比*/\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n        }\n        return landResourceInfos;\n    }\n<br>\n\n\n### 5.<font size=\"5\" face=\"黑体\">**图形展示**</font><br>\n\n>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。\n\n\t/**\n     * 结果列表点击效果\n     */\n    private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n        @Override\n        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n            resultDrawerLayer.removeAll();\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n            Envelope tempEnvelope = new Envelope();\n            landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n            Point tempPoint = tEnvelope.getCenter();\n            mapView_main.centerAt(tempPoint,true);\n        }\n    };\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。\n\n<font  size = 3>[相关关键代码查看](https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90 \"点击进去作者Git\")</font>\n<br>\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n","content":"<header><br><td bgcolor=\"#0099ff\"><br><br>   <center><table><tr><td bgcolor=\"#333333\"><font size=\"7\" face=\"黑体\" color=\"#ffffff\"><strong>移动用地分析功能</strong></font></td></tr></table></center><br><br><br></td><br></header>\n\n\n\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>简介</strong></font></h2><font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font><br><br><br><font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font><br><br><br><font color=\"#664499\" size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font>\n\n\n<hr>\n\n<p><br></p>\n<h2 id=\"实现逻辑略析\"><a href=\"#实现逻辑略析\" class=\"headerlink\" title=\"实现逻辑略析\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>实现逻辑略析</strong></font></h2><ol>\n<li>可视化与相关功能操作窗口的基本实现<br></li>\n</ol>\n<ol start=\"2\">\n<li>加载功能基础的地图底图与分析操作图层<br></li>\n</ol>\n<ol start=\"3\">\n<li>分析区域的选择并获取当前图形<br></li>\n</ol>\n<ol start=\"4\">\n<li><font color=\"#664499\">离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br></li>\n</ol>\n<ol start=\"5\">\n<li><font color=\"#664499\">获得结果FeatureResult，从中获取Geometry<font color=\"#ee0000\">（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br></li>\n</ol>\n<ol start=\"6\">\n<li><font color=\"#664499\">图形切割与面积计算</font><br></li>\n</ol>\n<ol start=\"7\">\n<li>通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br></li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"重要部分代码实现\"><a href=\"#重要部分代码实现\" class=\"headerlink\" title=\"重要部分代码实现\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>重要部分代码实现</strong></font></h2><h3 id=\"1-分析区域选择\"><a href=\"#1-分析区域选择\" class=\"headerlink\" title=\"1.分析区域选择\"></a>1.<font size=\"5\" face=\"黑体\"><strong>分析区域选择</strong></font><br></h3><pre><code>//通过多点集合绘制几何图形\npolygon.lineTo(currentPoint);\ncurrentGraphic = new Graphic(polygon, symbol);\ndrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\npointGraphic=new Graphic(multiPoint,pointSymbol);\ndrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\nmultiPoint.add(currentPoint);\nif(lastGraphicIndex!=-1){\n    drawLayer.removeGraphic(lastGraphicIndex);\n}\nlastGraphic=new Graphic(currentPoint,lastSymbol);\nlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n</code></pre><p><br></p>\n<h3 id=\"2-地图查询\"><a href=\"#2-地图查询\" class=\"headerlink\" title=\"2.地图查询\"></a>2.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>地图查询</strong></font><br></h3><blockquote>\n<p>  离线查询</p>\n</blockquote>\n<p>离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\n//设置区域\nif (isALL) {\nqueryParams.setGeometry(mapView_main.getExtent());\n}else {\n    Polygon queryPolygon=measureManager.getpolygon();\n    queryParams.setGeometry(queryPolygon);\n}\n//设置过滤字段\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();                    \nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nFeatureLayer featureLayer=(FeatureLayer)layer;\nresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\ntry {\n    //获取结果\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    Iterator it = featureResult.iterator();\n     while (it.hasNext()){\n    GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n    Geometry geometry=geodatabaseFeature.getGeometry();\n    &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes();\n\n    if(geometry!=null){\n        //进行图形处理\n    }\n    if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n        //进行内容详情提取处理\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线查询</p>\n</blockquote>\n<p>在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\nPolygon Querypolygon=measureManager.getpolygon();\nqueryParams.setGeometry(Querypolygon);\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();\nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\nQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\nresultFuture=queryTask.execute(queryParams, callbackListener);\ntry {\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    for (Object element : featureResult) {\n        if (element instanceof Feature) {\n            Feature f = (Feature) element;\n            Geometry geometry=f.getGeometry();\n            Map&lt;String, Object&gt; featureMap=f.getAttributes();\n            if(geometry!=null){\n                //进行图形处理\n            }\n            if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n                //进行内容详情提取处理\n            }\n        }\n    }\n}        \n</code></pre><p><br></p>\n<h3 id=\"3-图形交叉处理\"><a href=\"#3-图形交叉处理\" class=\"headerlink\" title=\"3.图形交叉处理\"></a>3.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>图形交叉处理</strong></font><br></h3><blockquote>\n<p> 通过调用GeometeyEngine.intersect()方法获取。</p>\n</blockquote>\n<pre><code>Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n</code></pre><p><br></p>\n<h3 id=\"4-面积计算\"><a href=\"#4-面积计算\" class=\"headerlink\" title=\"4.面积计算\"></a>4.<font size=\"5\" face=\"黑体\"><strong>面积计算</strong></font><br></h3><blockquote>\n<p>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br><br>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。</p>\n</blockquote>\n<pre><code>/**\n *通过在地图上的Area大小计算百分比与实际面积\n *\n * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n * @return 一个结果的数组 变更了参数数组中成员的属性\n */\npublic static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){\n    /*计算实际面积 */\n    double MUM=0;\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        if (landResourceInfo.getYDMJ()==null) {\n            landResourceInfos.remove(landResourceInfo);\n            continue;\n        }\n        Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n        Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n        Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n        landResourceInfo.setYDMJ(realArea);\n\n        //累计求和\n        MUM=MUM+landResourceInfo.getYDMJ();\n    }\n    /*分别计算百分比*/\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n    }\n    return landResourceInfos;\n}\n</code></pre><p><br></p>\n<h3 id=\"5-图形展示\"><a href=\"#5-图形展示\" class=\"headerlink\" title=\"5.图形展示\"></a>5.<font size=\"5\" face=\"黑体\"><strong>图形展示</strong></font><br></h3><blockquote>\n<p>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。</p>\n</blockquote>\n<pre><code>/**\n * 结果列表点击效果\n */\nprivate AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n    @Override\n    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {\n        resultDrawerLayer.removeAll();\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n        Envelope tempEnvelope = new Envelope();\n        landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n        Point tempPoint = tEnvelope.getCenter();\n        mapView_main.centerAt(tempPoint,true);\n    }\n};\n</code></pre><p><hr><br><br></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font></h2><p>&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。</p>\n<p><font size=\"3\"><a href=\"https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90\" title=\"点击进去作者Git\" target=\"_blank\" rel=\"noopener\">相关关键代码查看</a></font><br><br><br><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>\n\n","slug":"landanalysis","updated":"2018-09-28T08:08:49.977Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/08/13/landanalysis/","excerpt":"","categories":[{"name":"张泉","slug":"张泉","permalink":"http://yoursite.com/categories/张泉/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]}